# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка. В
# его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число). В классе должны
# быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()),
# умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только к клеткам и выполнять
# увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух
# клеток. Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух
# клеток больше нуля, иначе выводить соответствующее сообщение. Умножение. Создаётся общая клетка из двух. Число
# ячеек общей клетки определяется как произведение количества ячеек этих двух клеток. Деление. Создаётся общая клетка
# из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный
# метод позволяет организовать ячейки по рядам. Метод должен возвращать строку вида *****\n*****\n*****...,
# где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает,
# то в последний ряд записываются все оставшиеся. Например, количество ячеек клетки равняется 12, количество ячеек в
# ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**. Или, количество ячеек клетки равняется 15,
# количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n*****. Подсказка: подробный
# список операторов для перегрузки доступен по ссылке.

class Cell:
    _count: int

    def __str__(self):
        return f"Строка: {self._count * '*'}"

    def __init__(self, count):
        self._count = count

    def __add__(self, other: 'Cell'):
        return Cell(self._count + other._count)

    def __sub__(self, other: 'Cell'):
        return Cell(self._count - other._count) if self._count - other._count > 0 else "Невозможно сделать слияние, результат меньше нуля"

    def __mul__(self, other: 'Cell'):
        return Cell(int(self._count * other._count))

    def __truediv__(self, other: 'Cell'):
        return Cell(int(self._count / other._count))

    def __mod__(self, other: 'Cell'):
        return Cell(self._count % other._count)

    def make_order(self, count_in_line: int):
        return '\\n'.join(['*' * count_in_line for i in range(int(self._count / count_in_line))]
                          + (['*' * (self._count % count_in_line)]
                             if self._count % count_in_line > 0
                             else [])
                          )


cells = [Cell(6), Cell(10), Cell(24), Cell(25), Cell(8)]
print("\nmake_order")
for i in cells:
    print(i.make_order(len(cells)))

print("\nВычитания")
print(cells[0] - cells[1])
print(cells[1] - cells[0])
print(cells[0] - cells[2])

print("\nСложения")
print(cells[2] + cells[1])
print(cells[0] + cells[2])
print(cells[4] + cells[3])

print("\nДеления")
print(cells[0] / cells[1])
print(cells[2] / cells[1])
print(cells[3] / cells[4])

print("\nУмножения")
print(cells[0] * cells[1])
print(cells[0] * cells[4])

